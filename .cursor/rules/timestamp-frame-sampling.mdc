---
description: タイムスタンプ抽出とフレームサンプリングの実装ガイドライン
---

# タイムスタンプベースのフレームサンプリング

## 概要

タイムラプス動画から、タイムスタンプを基準に 5 分刻みのフレームを抽出します。

## タイムスタンプ抽出

### TimestampExtractor

[timestamp_extractor.py](mdc:src/timestamp_extractor.py) は、フレームの右上からタイムスタンプを OCR で読み取ります。

```python
import cv2
import numpy as np
import pytesseract
from typing import Optional, Tuple
import re

class TimestampExtractor:
    def __init__(self, roi: Tuple[int, int, int, int] = None):
        """
        Args:
            roi: タイムスタンプ領域 (x, y, width, height)
                 デフォルト: (900, 10, 350, 60) - 右上領域
        """
        self.roi = roi or (900, 10, 350, 60)
```

### OCR 前処理

精度向上のため、ROI 領域を前処理:

```python
def _preprocess_roi(self, frame: np.ndarray) -> np.ndarray:
    """OCR用の前処理"""
    x, y, w, h = self.roi
    roi_image = frame[y:y+h, x:x+w]

    # グレースケール変換
    gray = cv2.cvtColor(roi_image, cv2.COLOR_BGR2GRAY)

    # コントラスト強調 (CLAHE)
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
    enhanced = clahe.apply(gray)

    # 二値化 (Otsuの方法)
    _, binary = cv2.threshold(enhanced, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

    # ノイズ除去 (モルフォロジー変換)
    kernel = np.ones((2, 2), np.uint8)
    cleaned = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel)

    return cleaned
```

### タイムスタンプ抽出

```python
def extract(self, frame: np.ndarray) -> Optional[str]:
    """フレームからタイムスタンプを抽出

    Returns:
        "HH:MM" 形式の文字列、または None（読み取り失敗時）
    """
    preprocessed = self._preprocess_roi(frame)

    # Tesseract設定: 数字と記号のみ認識
    custom_config = r'--oem 3 --psm 7 -c tessedit_char_whitelist=0123456789:'

    try:
        ocr_text = pytesseract.image_to_string(preprocessed, config=custom_config)
        timestamp = self.parse_timestamp(ocr_text)
        return timestamp
    except Exception as e:
        logging.warning(f"タイムスタンプ抽出失敗: {e}")
        return None

def parse_timestamp(self, ocr_text: str) -> Optional[str]:
    """OCR結果から時刻を抽出・正規化"""
    # HH:MM形式を検索
    pattern = r'(\d{1,2}):(\d{2})'
    match = re.search(pattern, ocr_text)

    if match:
        hours = int(match.group(1))
        minutes = int(match.group(2))

        # 妥当性チェック
        if 0 <= hours <= 23 and 0 <= minutes <= 59:
            return f"{hours:02d}:{minutes:02d}"

    return None
```

## フレームサンプリング

### FrameSampler

[frame_sampler.py](mdc:src/frame_sampler.py) は、5 分刻みのフレームを抽出します。

```python
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Tuple

class FrameSampler:
    def __init__(self, interval_minutes: int = 5, tolerance_seconds: int = 10):
        """
        Args:
            interval_minutes: サンプリング間隔（分）
            tolerance_seconds: 許容誤差（秒）±10秒
        """
        self.interval_minutes = interval_minutes
        self.tolerance_seconds = tolerance_seconds
```

### 目標タイムスタンプ生成

```python
def find_target_timestamps(self, start_time: str, end_time: str) -> List[str]:
    """5分刻みの目標タイムスタンプリストを生成

    Args:
        start_time: 開始時刻 "HH:MM"
        end_time: 終了時刻 "HH:MM"

    Returns:
        ["12:10", "12:15", "12:20", ...] のような5分刻みリスト
    """
    start = datetime.strptime(start_time, "%H:%M")
    end = datetime.strptime(end_time, "%H:%M")

    # 開始時刻を5分刻みに切り上げ
    minutes = (start.minute // self.interval_minutes + 1) * self.interval_minutes
    current = start.replace(minute=0) + timedelta(minutes=minutes)

    targets = []
    while current <= end:
        targets.append(current.strftime("%H:%M"))
        current += timedelta(minutes=self.interval_minutes)

    return targets
```

### 最近接フレーム検索

```python
def find_closest_frame(
    self,
    target_timestamp: str,
    frame_timestamps: Dict[int, str]
) -> Optional[int]:
    """目標タイムスタンプに最も近いフレーム番号を返す

    Args:
        target_timestamp: 目標時刻 "HH:MM"
        frame_timestamps: {frame_number: "HH:MM"} の辞書

    Returns:
        フレーム番号、または None（±10秒以内に該当フレームがない場合）
    """
    target = datetime.strptime(target_timestamp, "%H:%M")
    tolerance = timedelta(seconds=self.tolerance_seconds)

    closest_frame = None
    min_diff = tolerance

    for frame_num, timestamp in frame_timestamps.items():
        frame_time = datetime.strptime(timestamp, "%H:%M")
        diff = abs((frame_time - target).total_seconds())

        if diff <= self.tolerance_seconds and diff < min_diff.total_seconds():
            min_diff = timedelta(seconds=diff)
            closest_frame = frame_num

    return closest_frame
```

### フレーム抽出フロー

```python
def extract_sample_frames(
    self,
    video_processor: VideoProcessor,
    timestamp_extractor: TimestampExtractor
) -> List[Tuple[int, str]]:
    """動画全体をスキャンし、5分刻みのフレームを抽出

    Returns:
        [(frame_number, timestamp), ...] のリスト
    """
    frame_timestamps = {}
    frame_number = 0

    # ステップ1: 全フレームスキャン（効率化のため一定間隔でスキップ可能）
    while True:
        frame = video_processor.get_frame(frame_number)
        if frame is None:
            break

        timestamp = timestamp_extractor.extract(frame)
        if timestamp:
            frame_timestamps[frame_number] = timestamp

        frame_number += 1

    if not frame_timestamps:
        raise ValueError("タイムスタンプを抽出できませんでした")

    # ステップ2: 開始・終了時刻を特定
    timestamps_list = list(frame_timestamps.values())
    start_time = min(timestamps_list)
    end_time = max(timestamps_list)

    # ステップ3: 目標タイムスタンプを生成
    target_timestamps = self.find_target_timestamps(start_time, end_time)

    # ステップ4: 各目標に最も近いフレームを選定
    sample_frames = []
    for target in target_timestamps:
        closest = self.find_closest_frame(target, frame_timestamps)
        if closest is not None:
            sample_frames.append((closest, frame_timestamps[closest]))
        else:
            logging.warning(f"目標時刻 {target} に該当するフレームが見つかりません")

    return sample_frames
```

## 統合例

```python
# 初期化
video_processor = VideoProcessor("input/merged_moviefiles.mov")
video_processor.open()

timestamp_extractor = TimestampExtractor()
frame_sampler = FrameSampler(interval_minutes=5, tolerance_seconds=10)

# 5分刻みフレーム抽出
sample_frames = frame_sampler.extract_sample_frames(video_processor, timestamp_extractor)

print(f"抽出フレーム数: {len(sample_frames)}")
for frame_num, timestamp in sample_frames:
    print(f"フレーム {frame_num}: {timestamp}")
```

## 設定 (config.yaml)

```yaml
video:
  input_path: "input/merged_moviefiles.mov"
  is_timelapse: true
  frame_interval_minutes: 5 # 5分刻み
  tolerance_seconds: 10 # ±10秒許容
```

## パフォーマンス最適化

- **スキップサンプリング**: 全フレームではなく、数フレームごとに OCR を実行（タイムラプスなので変化が少ない）
- **並列処理**: 複数フレームの OCR を並列実行（オプション）
- **キャッシング**: 一度抽出したタイムスタンプをキャッシュ
